//! The goal of this mod is to ensure the launcher shell function
//! is available i.e. the `br` shell function can be used to launch
//! broot (and thus make it possible to execute some commands, like `cd`,
//! from the starting shell.
//!
//! When everybody's OK, the resulting config dir looks like this:
//!
//!    /home/dys/.config/broot
//!    ├──conf.toml
//!    └──launcher
//!       ├──bash
//!       │  ├──1
//!       │  └──br -> /home/dys/.config/broot/launcher/bash/1
//!       └──installed
//!
//! and a "source .config/broot/launcher/bash/br" line is written in
//! the .bashrc file
//!
//! (when the shell is a bash, br's version is 1 and the user is "dys")
//!
//! If the user refused the installation, a "refused" file takes the
//! place of the "installed" one.


use std::env;
use std::fs;
use std::io::{self, Write, BufRead, BufReader};
use std::os::unix::fs::symlink;
use std::path::Path;
use std::fs::OpenOptions;

use directories::UserDirs;
use regex::Regex;
use termion::style;

use crate::conf;
use crate::cli::{self, AppLaunchArgs};

// if we start to handle several shell families, we'll make the appropriate
// structure and versions will be by shell function. Right now it would be
// useless
const SHELL_FUNC_VERSION: usize = 1;

// This script has been tested on bash and zsh
const SHELL_FUNC: &str = r#"
# This script was automatically generated by the broot function
# More information can be found in https://github.com/Canop/broot/blob/master/documentation.md

# This function starts broot and executes the command
# it produces, if any.
# It's needed because some shell commands, like `cd`,
# have no useful effect if executed in a subshell.
function br {
    f=$(mktemp)
    (
	set +e
	broot --outcmd "$f" "$@"
	code=$?
	if [ "$code" != 0 ]; then
	    rm -f "$f"
	    exit "$code"
	fi
    )
    code=$?
    if [ "$code" != 0 ]; then
	return "$code"
    fi
    d=$(cat "$f")
    rm -f "$f"
    if [ "$(wc -c <(echo -n "$d") | head -c1)" != 0 ]; then
	eval "$d"
    fi
}
"#;

fn ensure_shell_script_installed(launcher_dir: &Path, shellname: &str) -> io::Result<()> {
    let dir = launcher_dir.join(&shellname);
    let link_path = dir.join("br");
    let link_present = link_path.exists();
    let script_path = dir.join(SHELL_FUNC_VERSION.to_string());
    let func_present = script_path.exists();
    if !func_present {
        info!("script_path not present: writing it");
        fs::create_dir_all(dir)?;
        fs::write(&script_path, SHELL_FUNC)?;
        if link_present {
            fs::remove_file(&link_path)?;
        }
    }
    if !func_present || !link_present {
        info!("creating link from {:?} to {:?}", &link_path, &script_path);
        symlink(&script_path, &link_path)?;
    }
    Ok(())
}

fn ask_authorization(shellrc_path: &Path) -> io::Result<bool> {
    println!("{}Broot{} should be launched using a shell function", style::Bold, style::Reset);
    println!("(see https://github.com/Canop/broot for explanations).");
    println!("The function is either missing, old or badly installed.");
    cli::ask_authorization(&format!("Can we add a line to {:?} ? [Y n]", shellrc_path))
}

fn file_contains_line(path: &Path, searched_line: &str) -> io::Result<bool> {
    for line in BufReader::new(fs::File::open(path)?).lines() {
        if line? == searched_line {
            return Ok(true);
        }
    }
    Ok(false)
}

/// return true if the application should quit
fn maybe_patch_shellrc(launcher_dir: &Path, shellname: &str, installation_required: bool) -> io::Result<bool> {
    let installed_path = launcher_dir.join("installed");
    if installed_path.exists(){
        debug!("*installed* file found");
        // everything seems OK
        if !installation_required {
            return Ok(false);
        }
    }
    let refused_path = launcher_dir.join("refused");
    if refused_path.exists(){
        debug!("*refused* file found :(");
        if installation_required {
            fs::remove_file(&refused_path)?;
        } else {
            // user doesn't seem to want the shell function
            return Ok(false);
        }
    }
    // it looks like the shell function is neither installed nor refused
    let homedir_path = match UserDirs::new() {
        Some(user_dirs) => user_dirs.home_dir().to_path_buf(),
        None => {
            warn!("no home directory found!");
            return Ok(false);
        }
    };
    let shellrc_path = homedir_path.join(format!(".{}rc", shellname));
    if !shellrc_path.exists() {
        warn!("no {:?} file found, we can't install the br function", &shellrc_path);
        if installation_required {
            println!("no {:?} file found, we can't install the br function", &shellrc_path);
        }
        return Ok(installation_required);
    }
    if !installation_required {
        let proceed = ask_authorization(&shellrc_path)?;
        debug!("proceed: {:?}", proceed);
        if !proceed {
            // user doesn't want the shell function, let's remember it
            fs::write(&refused_path, "to install the br function, run broot --install")?;
            println!("Okey. If you change your mind, use ̀ broot --install`.");
            return Ok(false);
        }
    }
    // user is OK, let's try to patch his shellrc
    let source_line = format!("\nsource {}/{}/br", launcher_dir.to_string_lossy(), &shellname);
    if file_contains_line(&shellrc_path, &source_line)? {
        println!("{:?} already patched, no change made.", shellrc_path);
    } else {
        let mut shellrc = OpenOptions::new().write(true).append(true).open(&shellrc_path)?;
        shellrc.write_all(source_line.as_bytes())?;
        println!("{:?} successfully patched, you should now refresh it with.", shellrc_path);
        println!("  source {}", shellrc_path.to_string_lossy());
        println!("You should afterwards start broot with just {}br{}.", style::Bold, style::Reset);
    }
    // signal if there's an old br function declared in the shellrc file
    // (which was the normal way to install before broot 0.6)
    if file_contains_line(&shellrc_path, "function br {")? {
        println!(
            "Your {} contains another br function, maybe dating from an old version of broot.",
            shellrc_path.to_string_lossy()
        );
        println!("You should remove it.");
    }
    // and remember we did it
    fs::write(&installed_path, "to reinstall the br function, run broot --install")?;
    Ok(true)
}

/// check whether the shell function is installed, install
/// it if it wasn't refused before or if broot is launched
/// with --install.
/// returns true if the app should quit
pub fn init(launch_args: &AppLaunchArgs) -> io::Result<bool> {
    let launcher_dir = conf::dir().join("launcher");
    let shell = env::var("SHELL").unwrap();
    let sr = Regex::new(r"[^/]*$").unwrap();
    let shellname = match sr.find(&shell) {
        Some(m) => m.as_str().to_string(),
        None => {
            warn!("invalid SHELL in env");
            return Ok(false);
        }
    };
    // we always add and update the shell script
    ensure_shell_script_installed(&launcher_dir, &shellname)?;
    // but for patching the shellrc file, we need
    // some authorization
    maybe_patch_shellrc(&launcher_dir, &shellname, launch_args.install)
}
